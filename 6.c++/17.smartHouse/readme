introduction:

smart house is a next generation platform for managing communication between devices in a building.
the SDK provides interface to connect devices to send and recive events, as well as an example showing
how the system works. 




Agent:

An agent is	the	software entity	loaded by the server to	represent an actual	device.
agents will be implemented as a dynamic object(.SO) as described bellow.

Agents will be implemented as a c++ class derived from the provided "Agent" class.
agents should have at least one constructor that gets const AgentData& and Hub* as its input.
it should than pass it to the Agent base class constructor.

agents should take care to run in parallel with the rest of the system. no thread will be dedicated 
by the system to run the softwere. although an agent may create thread by himself.

every agent should belong to at least one of the following categories:

1) Sensor:	
	A device that monitors and measures	a physical phenomena.		
	A sensor will publish the result of	measurement/sensing	as an event	to the system.
	snesors will publish this results as Events by calling SendEvent function of the Hub.
	
2) Controller:	
	A device that will execute an operation. Usually affecting the environment.
	agents will subscribe to the hub using its Subscribe function, and unsubscribe using
	the Unsubscribe function.
	
	in order to recive events controllers should overload two functions defined in the Agent
	base class:
	1) bool IsRelevantEvent(const Event& _event) - predicate function returnning if the event should be sent
	   to the controller or not.
	   
	2) void ReciveEvent(const Event& _event) - the device function handling the event.
	
	
	
	
Hub:

interface provided by the system to handle communication between the system and the provided agents.
provides the following functions:
1) void SendEvent(Event) - publish event to the system
2) void Subscribe(Agent*) - subscribe to recive events
3) void Unsubscribe(Agent*) - unsubscribe from reciving events




Event:

The	system	will enable	devices	to generate	and	send custom	events.	Events will	be generated by sensor
agents and will be consumed by controller agents. An event will consist of a type/topic, location info
and arbitrary agent event specific payload.

Events will be implemented using the EventImp class or a provided class that derived from him.
they must be sent as an Event class instance(shared ptr) who gets EventImp as its input.




shared objects:

in order to load agets to the system all agents will be implemented in a shared object(.SO).
all shared object file names must end with .so .
all shared objects will be placed in the same directory. the directory path will be provided to the 
softwere in the commend line. if no path is inserted default path will be used ("/sharedObjects/")




configuration file:

The	configuration file will	list the details of	devices	present	in the building. This	
map	will serve to create the devices and manage the topology of these devices.

The	configuration file is normal INI file with one section for every device. This	
section	will have the following format (order is not strict):	
	
[devic-id a	unique device instance identification string ]	
type = device-type
room = room-identification	
floor = floor-designation	
log = log name to be used by the device. (optional - will use default log file ("log.log") if not provided)
config = a device specific configuration string	(optional)

type must start with the SO file name(without the .so) seperated by '-' followed by the actual type name.
example: "nadavElectric-HVAC" for device type HVAC in the nadavElectric.so shared object




logger:

the system provides a built in logger for devices to use (Nlog class).
the log will be available as a data member of the agent.
the name of the logger to use will be defined in the configuration file.

the logger class provides the following functions:
void Write(const string&) - write a string to the log.
void Flush() - flush the log buffer.

the logger will also flush the buffer at program exit.




running the program:

the program would run through the commend line using the following flags:
-c: path of the configuration file.
-s: path of the directory holding the shared object.
-l: path to save the log files in.

if any of the paths is not defined, a default path will be used:
configuration file: "config.ini"
shared objects: "/sharedObjects"
log files: "/log"

if any of the paths does not exist the program will not run.

